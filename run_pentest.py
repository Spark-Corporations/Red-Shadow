"""
RedClaw V3.1 - Live Pentest Integration Test
Target: 192.168.1.83

Tests the full pipeline:
  1. Initialize MemAgent + KnowledgeGraph
  2. Brain analyzes target -> planning
  3. Run nmap scan (activity)
  4. Ingest results into KnowledgeGraph
  5. Brain + Hands analyze results -> exploit strategy
  6. Generate CausalChain report
"""
import asyncio
import json
import logging
import os
import sys
import tempfile
import time

# Fix Windows encoding
if sys.platform == "win32":
    sys.stdout.reconfigure(encoding="utf-8", errors="replace")

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "src"))

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(name)s] %(levelname)s: %(message)s",
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger("redclaw.pentest")

TARGET = "192.168.1.83"
API_KEY = "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"
WORK_DIR = os.path.join(tempfile.gettempdir(), "redclaw_pentest_test")


def banner(title):
    print(f"\n{'=' * 60}")
    print(f"  {title}")
    print(f"{'=' * 60}\n", flush=True)


async def main():
    start_time = time.time()
    errors = []

    # ============================================================
    # PHASE 1: Initialize components
    # ============================================================
    banner("PHASE 1: Initialize Components")

    # MemAgent
    try:
        from redclaw.memory.memagent import MemAgent
        mem = MemAgent(working_dir=WORK_DIR)
        mem.initialize(f"Integration Test - {TARGET}")
        print(f"  [OK] MemAgent initialized at {WORK_DIR}", flush=True)
    except Exception as e:
        errors.append(("MemAgent init", str(e)))
        print(f"  [ERR] MemAgent: {e}", flush=True)
        import traceback; traceback.print_exc()

    # KnowledgeGraph
    try:
        from redclaw.memory.knowledge_graph import PentestKnowledgeGraph
        kg = PentestKnowledgeGraph()
        print("  [OK] KnowledgeGraph initialized", flush=True)
    except Exception as e:
        errors.append(("KnowledgeGraph init", str(e)))
        print(f"  [ERR] KnowledgeGraph: {e}", flush=True)

    # SharedTaskList
    try:
        from redclaw.agents.shared_task_list import SharedTaskList
        tasks = SharedTaskList(db_path=os.path.join(WORK_DIR, "tasks.db"))
        print("  [OK] SharedTaskList initialized", flush=True)
    except Exception as e:
        errors.append(("SharedTaskList init", str(e)))
        print(f"  [ERR] SharedTaskList: {e}", flush=True)

    # Mailbox
    try:
        from redclaw.agents.mailbox import Mailbox
        mailbox = Mailbox(db_path=os.path.join(WORK_DIR, "mailbox.db"))
        mailbox.register_agent("brain")
        mailbox.register_agent("hands")
        mailbox.register_agent("recon")
        print("  [OK] Mailbox initialized (3 agents registered)", flush=True)
    except Exception as e:
        errors.append(("Mailbox init", str(e)))
        print(f"  [ERR] Mailbox: {e}", flush=True)

    # LockManager
    try:
        from redclaw.agents.lock_manager import LockManager
        locks = LockManager(lock_dir=os.path.join(WORK_DIR, "locks"))
        print("  [OK] LockManager initialized", flush=True)
    except Exception as e:
        errors.append(("LockManager init", str(e)))
        print(f"  [ERR] LockManager: {e}", flush=True)

    # OpenRouter Client
    try:
        from redclaw.router.openrouter_client import OpenRouterClient
        client = OpenRouterClient(api_key=API_KEY)
        print(f"  [OK] OpenRouter: brain={client.BRAIN.model_id}", flush=True)
        print(f"                   hands={client.HANDS.model_id}", flush=True)
    except Exception as e:
        errors.append(("OpenRouter init", str(e)))
        print(f"  [ERR] OpenRouter: {e}", flush=True)

    # CausalChainReport
    try:
        from redclaw.reporting.causal_chain import CausalChainReport
        reporter = CausalChainReport(output_dir=os.path.join(WORK_DIR, "reports"))
        print("  [OK] CausalChainReport initialized", flush=True)
    except Exception as e:
        errors.append(("Reporter init", str(e)))
        print(f"  [ERR] Reporter: {e}", flush=True)

    # ============================================================
    # PHASE 2: Brain Planning
    # ============================================================
    banner("PHASE 2: Brain Planning")
    mem.set_status("PLANNING")
    mem.add_pending_tasks([
        {"id": "recon_nmap", "description": f"Nmap scan on {TARGET}"},
        {"id": "recon_nuclei", "description": f"Nuclei scan on {TARGET}"},
        {"id": "analyze", "description": "Analyze scan results"},
        {"id": "exploit_plan", "description": "Plan exploitation strategy"},
        {"id": "report", "description": "Generate final report"},
    ])

    # Add tasks to SharedTaskList
    tasks.add_task("recon_nmap", f"Nmap port scan on {TARGET}", [], priority=10)
    tasks.add_task("recon_nuclei", f"Nuclei vuln scan on {TARGET}", [], priority=8)
    tasks.add_task("analyze", "Analyze scan results", ["recon_nmap", "recon_nuclei"], priority=5)
    tasks.add_task("exploit_plan", "Plan exploitation", ["analyze"], priority=3)
    tasks.add_task("report", "Generate report", ["exploit_plan"], priority=1)

    # Ask Brain for initial plan
    try:
        plan_prompt = f"""You are a pentester planning an engagement against {TARGET} (local network).
List the top 5 things to check first. Be concise, one line each."""

        plan = await client.call_brain(plan_prompt, temperature=0.3)
        mem.update_task_status("plan", "COMPLETE", plan[:200])
        print(f"  [OK] Brain plan:\n{plan[:400]}", flush=True)
    except Exception as e:
        errors.append(("Brain planning", str(e)))
        print(f"  [ERR] Brain: {e}", flush=True)

    await asyncio.sleep(5)  # Rate limit buffer

    # ============================================================
    # PHASE 3: Nmap Recon
    # ============================================================
    banner("PHASE 3: Nmap Recon")
    mem.set_status("RECON")

    # Claim task
    task = tasks.claim_task("recon_agent")
    print(f"  [OK] Claimed task: {task['task_id'] if task else 'NONE'}", flush=True)

    # Acquire lock on target
    if locks.acquire(f"nmap_{TARGET}", "recon_agent"):
        print(f"  [OK] Lock acquired: nmap_{TARGET}", flush=True)
    else:
        print(f"  [WARN] Could not acquire nmap lock", flush=True)

    # Run nmap scan (from activities)
    from redclaw.orchestrator.activities import run_nmap_activity
    mem.update_task_status("recon_nmap", "RUNNING", "Starting nmap scan")

    print(f"  [..] Running nmap on {TARGET}...", flush=True)
    nmap_result = await run_nmap_activity(TARGET)

    if nmap_result.get("error"):
        print(f"  [WARN] Nmap error: {nmap_result['error']}", flush=True)
        errors.append(("Nmap", nmap_result['error']))
        # Create mock data for pipeline testing
        nmap_result = {
            "target": TARGET,
            "open_ports": [22, 80, 443, 3306, 8080],
            "services": [
                {"port": 22, "name": "ssh", "version": "OpenSSH 8.2"},
                {"port": 80, "name": "http", "version": "Apache 2.4.49"},
                {"port": 443, "name": "https", "version": "nginx 1.18"},
                {"port": 3306, "name": "mysql", "version": "MySQL 5.7.36"},
                {"port": 8080, "name": "http-proxy", "version": "Jetty 9.4"},
            ],
            "note": "MOCK DATA - nmap not available",
        }
        print("  [INFO] Using mock data for pipeline testing", flush=True)

    mem.update_task_status("recon_nmap", "COMPLETE",
                           f"Found {len(nmap_result['open_ports'])} ports: {nmap_result['open_ports']}")
    tasks.complete_task("recon_nmap", json.dumps(nmap_result, default=str))

    # Release lock
    locks.release(f"nmap_{TARGET}", "recon_agent")
    print(f"  [OK] Nmap complete: {len(nmap_result['open_ports'])} open ports", flush=True)
    for svc in nmap_result.get("services", []):
        print(f"       {svc['port']}/tcp - {svc['name']} {svc.get('version', '')}", flush=True)

    # Send results via mailbox
    mailbox.send("recon", "brain", {"type": "nmap_complete", "result": nmap_result})
    print("  [OK] Results sent via Mailbox -> brain", flush=True)

    # ============================================================
    # PHASE 4: Ingest into KnowledgeGraph
    # ============================================================
    banner("PHASE 4: KnowledgeGraph Ingestion")

    kg.add_host(TARGET)
    for svc in nmap_result.get("services", []):
        kg.add_port(TARGET, svc["port"], "open")
        kg.add_service(TARGET, svc["port"], svc["name"], svc.get("version", ""))
        print(f"  [OK] Added: {TARGET}:{svc['port']} -> {svc['name']} {svc.get('version', '')}", flush=True)

    stats = kg.get_stats()
    print(f"  [OK] Graph: {stats['total_nodes']} nodes, {stats['total_edges']} edges", flush=True)

    # Complete nuclei task (mock since nuclei likely not installed)
    tasks.complete_task("recon_nuclei", json.dumps({"target": TARGET, "vulnerabilities": [], "note": "nuclei not available"}))
    mem.update_task_status("recon_nuclei", "COMPLETE", "Nuclei scan completed (tool not available)")

    # ============================================================
    # PHASE 5: Brain Analysis + Hands Code
    # ============================================================
    banner("PHASE 5: Brain Analysis + Hands Exploit Planning")
    mem.set_status("ANALYSIS")

    # Claim analyze task (dependencies resolved)
    task = tasks.claim_task("analyze_agent")
    print(f"  [OK] Claimed task: {task['task_id'] if task else 'NONE'}", flush=True)

    # Brain analyzes findings
    try:
        services_desc = "\n".join(
            f"  - {s['port']}/tcp: {s['name']} {s.get('version', '')}"
            for s in nmap_result.get("services", [])
        )
        analysis_prompt = f"""Target: {TARGET}
Open ports and services:
{services_desc}

As a pentester, identify the top 3 most promising attack vectors. For each:
1. Service/port
2. Known vulnerability class
3. Quick one-line exploit approach
Be very concise."""

        analysis = await client.call_brain(analysis_prompt, temperature=0.3)
        mem.update_task_status("analyze", "COMPLETE", analysis[:200])
        tasks.complete_task("analyze", json.dumps({"analysis": analysis[:500]}))
        print(f"  [OK] Brain analysis:\n{analysis[:500]}", flush=True)

        # Add finding based on Apache 2.4.49
        for svc in nmap_result.get("services", []):
            if "apache" in svc.get("name", "").lower() and "2.4.49" in svc.get("version", ""):
                kg.add_vulnerability(
                    f"{TARGET}:{svc['port']}:{svc['name']}",
                    "CVE-2021-41773",
                    "critical",
                    9.8,
                )
                mem.add_finding("CVE-2021-41773 - Apache 2.4.49 Path Traversal RCE", "critical")
                print("  [OK] Finding: CVE-2021-41773 (critical, CVSS 9.8)", flush=True)
    except Exception as e:
        errors.append(("Brain analysis", str(e)))
        print(f"  [ERR] Brain analysis failed: {e}", flush=True)
        tasks.complete_task("analyze", json.dumps({"error": str(e)}))

    await asyncio.sleep(10)  # Rate limit buffer

    # Hands generates exploit code
    try:
        code_prompt = f"""Write a minimal Python script to test CVE-2021-41773 (Apache path traversal) against {TARGET}:80.
Use only stdlib (urllib, http.client). 10 lines max."""

        exploit_code = await client.call_hands(code_prompt, temperature=0.2)
        tasks.claim_task("exploit_agent")
        tasks.complete_task("exploit_plan", json.dumps({"exploit_code": exploit_code[:500]}))
        mem.update_task_status("exploit_plan", "COMPLETE", "Exploit code generated")
        print(f"  [OK] Hands exploit code:\n{exploit_code[:400]}", flush=True)
    except Exception as e:
        errors.append(("Hands exploit", str(e)))
        print(f"  [ERR] Hands exploit failed: {e}", flush=True)
        tasks.complete_task("exploit_plan", json.dumps({"error": str(e)}))

    # ============================================================
    # PHASE 6: Generate Report
    # ============================================================
    banner("PHASE 6: Generate Report")
    mem.set_status("REPORTING")

    finding = {
        "id": 1,
        "title": "Apache Path Traversal RCE",
        "cve": "CVE-2021-41773",
        "cvss": 9.8,
        "service": f"Apache 2.4.49 on {TARGET}:80",
        "impact": "Remote Code Execution",
        "root_cause": "Path normalization flaw in Apache 2.4.49 mod_cgi",
        "steps": [
            f"Nmap discovered Apache 2.4.49 on {TARGET}:80",
            "CVE database matched CVE-2021-41773 (CVSS 9.8)",
            "Path traversal via /cgi-bin/.%2e/%2e%2e/etc/passwd",
            "RCE confirmed via mod_cgi",
        ],
        "target": {"os": "Linux", "software": "Apache 2.4.49"},
    }

    validation = {
        "validated": True,
        "proof": {
            "http_status": "200 OK",
            "response_size": 1847,
            "timestamp": "2026-02-26T19:50:00",
        },
    }

    try:
        report_text = reporter.generate(finding, validation)
        print(f"  [OK] Single finding report generated ({len(report_text)} chars)", flush=True)

        full_report = reporter.generate_full_report(
            {
                "completed_tasks": [finding],
                "executive_summary": f"Penetration test of {TARGET} discovered critical Apache RCE.",
                "attack_path": {"entry": f"{TARGET}:80", "technique": "CVE-2021-41773", "impact": "RCE"},
            },
            f"Pentest - {TARGET}",
        )

        path = reporter.export_text(full_report)
        print(f"  [OK] Report exported to: {path}", flush=True)

        json_path = reporter.export_json(full_report)
        print(f"  [OK] JSON exported to: {json_path}", flush=True)

        tasks.complete_task("report", json.dumps({"report_path": path}))
        mem.update_task_status("report", "COMPLETE", f"Report exported to {path}")
    except Exception as e:
        errors.append(("Report generation", str(e)))
        print(f"  [ERR] Report: {e}", flush=True)
        import traceback; traceback.print_exc()

    # ============================================================
    # PHASE 7: Final Status
    # ============================================================
    banner("FINAL STATUS")
    mem.set_status("COMPLETE")

    # Check all tasks complete
    all_done = tasks.all_tasks_complete()
    print(f"  Tasks complete: {all_done}", flush=True)

    # Graph stats
    graph_stats = kg.get_stats()
    print(f"  Graph: {graph_stats}", flush=True)

    # MemAgent summary
    context = mem.get_context_summary()
    print(f"  Status: {context['status']}", flush=True)
    print(f"  Completed: {len(context['completed_tasks'])} tasks", flush=True)
    print(f"  Findings: {len(context['key_findings'])} findings", flush=True)

    # Mailbox check
    brain_msgs = mailbox.has_messages("brain")
    print(f"  Brain has messages: {brain_msgs}", flush=True)

    # Locks check
    any_locked = locks.is_locked(f"nmap_{TARGET}")
    print(f"  Stale locks: {any_locked}", flush=True)

    elapsed = time.time() - start_time
    print(f"\n  Total time: {elapsed:.1f}s", flush=True)

    # ============================================================
    # ERRORS SUMMARY
    # ============================================================
    if errors:
        banner("ERRORS FOUND")
        for name, err in errors:
            print(f"  [{name}] {err}", flush=True)
        print(f"\n  Total errors: {len(errors)}", flush=True)
    else:
        print("\n  NO ERRORS! All phases completed successfully.", flush=True)

    # Cleanup
    locks.cleanup()


if __name__ == "__main__":
    asyncio.run(main())
