"""
RedClaw V3.1 - Autonomous Pentest Runner

Usage:
    python -m redclaw.pentest 192.168.1.83

The system autonomously:
  1. Brain plans the engagement
  2. Runs recon tools (nmap, nuclei)
  3. KnowledgeGraph ingests results
  4. Brain analyzes + Hands generates exploits
  5. Validates findings
  6. Generates CausalChain report
"""
from __future__ import annotations

import asyncio
import json
import logging
import os
import re
import sys
import tempfile
import time
from datetime import datetime
from typing import Any, Dict, List, Optional

# Fix Windows console encoding
if sys.platform == "win32":
    try:
        sys.stdout.reconfigure(encoding="utf-8", errors="replace")
    except Exception:
        pass

logger = logging.getLogger("redclaw.pentest")


class RedClawPentest:
    """
    Autonomous pentest orchestrator that uses Brain + Hands models
    to plan, execute, analyze, and report a penetration test.
    """

    def __init__(self, target: str, api_key: str, work_dir: Optional[str] = None):
        self.target = target
        self.api_key = api_key
        self.work_dir = work_dir or os.path.join(
            os.path.expanduser("~/.redclaw"), "engagements",
            f"{target}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        )
        self.errors: List[Dict[str, str]] = []
        self.start_time = time.time()

        # Will be initialized in setup()
        self.client = None
        self.mem = None
        self.kg = None
        self.tasks = None
        self.mailbox = None
        self.locks = None
        self.reporter = None

    # ================================================================
    # Setup
    # ================================================================

    async def setup(self):
        """Initialize all V3.1 components."""
        self._print_banner("REDCLAW V3.1 AUTONOMOUS PENTEST")
        self._log(f"Target: {self.target}")
        self._log(f"Work dir: {self.work_dir}")
        self._log(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print()

        from redclaw.router.openrouter_client import OpenRouterClient
        from redclaw.memory.memagent import MemAgent
        from redclaw.memory.knowledge_graph import PentestKnowledgeGraph
        from redclaw.agents.shared_task_list import SharedTaskList
        from redclaw.agents.mailbox import Mailbox
        from redclaw.agents.lock_manager import LockManager
        from redclaw.reporting.causal_chain import CausalChainReport

        self.client = OpenRouterClient(api_key=self.api_key)
        self.mem = MemAgent(working_dir=self.work_dir)
        self.kg = PentestKnowledgeGraph()
        self.tasks = SharedTaskList(db_path=os.path.join(self.work_dir, "tasks.db"))
        self.mailbox = Mailbox(db_path=os.path.join(self.work_dir, "mailbox.db"))
        self.locks = LockManager(lock_dir=os.path.join(self.work_dir, "locks"))
        self.reporter = CausalChainReport(output_dir=os.path.join(self.work_dir, "reports"))

        # Register agents
        for agent in ["brain", "hands", "recon", "analyst"]:
            self.mailbox.register_agent(agent)

        self._log(f"Brain: {self.client.BRAIN.model_id}")
        self._log(f"Hands: {self.client.HANDS.model_id}")
        self._log("All components initialized")

    # ================================================================
    # Phase 1: Brain Planning
    # ================================================================

    async def phase_planning(self) -> str:
        """Brain creates a pentest plan."""
        self._print_banner("PHASE 1: BRAIN PLANNING")
        self.mem.initialize(f"Pentest {self.target}")
        self.mem.set_status("PLANNING")

        prompt = f"""You are a cybersecurity consultant performing an authorized security assessment.
Your client has given you permission to test their system at {self.target} (private LAN).

Create a concise recon plan. List exactly these steps:
1. What nmap scan flags to use
2. What services to look for
3. Top 5 CVEs to check based on common services
4. Any quick wins to try first

Be very concise, bullet points only. No explanations."""

        try:
            plan = await self.client.call_brain(prompt, temperature=0.3)
            self.mem.update_task_status("planning", "COMPLETE", plan[:300])
            self._log("Brain plan received:")
            print(plan[:600], flush=True)
            return plan
        except Exception as e:
            self._error("Brain planning", e)
            return "Default plan: nmap -sV -p- target, check common CVEs"

    # ================================================================
    # Phase 2: Recon (nmap)
    # ================================================================

    async def phase_recon(self) -> Dict[str, Any]:
        """Run nmap scan via activities module."""
        self._print_banner("PHASE 2: RECON (NMAP)")
        self.mem.set_status("RECON")

        # Lock the target
        self.locks.acquire(f"scan_{self.target}", "recon")

        from redclaw.orchestrator.activities import run_nmap_activity
        self.mem.update_task_status("nmap_scan", "RUNNING", f"Scanning {self.target}")
        self._log(f"Running nmap on {self.target}...")

        nmap_result = await run_nmap_activity(self.target)

        # Release lock
        self.locks.release(f"scan_{self.target}", "recon")

        if nmap_result.get("error"):
            self._log(f"Nmap issue: {nmap_result['error']}")
            self._log("Falling back to quick TCP connect scan...")

            # Fallback: Python-based port scan
            nmap_result = await self._python_port_scan(self.target)

        ports = nmap_result.get("open_ports", [])
        services = nmap_result.get("services", [])
        self.mem.update_task_status("nmap_scan", "COMPLETE",
                                    f"Found {len(ports)} open ports: {ports}")

        self._log(f"Found {len(ports)} open ports:")
        for svc in services:
            self._log(f"  {svc['port']}/tcp - {svc['name']} {svc.get('version', '')}")

        return nmap_result

    async def _python_port_scan(self, target: str) -> Dict[str, Any]:
        """Fallback port scanner using Python stdlib."""
        import socket
        common_ports = [21, 22, 23, 25, 53, 80, 110, 139, 143, 443, 445,
                        993, 995, 1433, 1521, 3306, 3389, 5432, 5900, 6379,
                        8080, 8443, 8888, 9090, 27017]

        open_ports = []
        services = []
        service_names = {
            21: "ftp", 22: "ssh", 23: "telnet", 25: "smtp", 53: "dns",
            80: "http", 110: "pop3", 139: "netbios", 143: "imap",
            443: "https", 445: "smb", 993: "imaps", 995: "pop3s",
            1433: "mssql", 1521: "oracle", 3306: "mysql", 3389: "rdp",
            5432: "postgresql", 5900: "vnc", 6379: "redis",
            8080: "http-proxy", 8443: "https-alt", 8888: "http-alt",
            9090: "proxy", 27017: "mongodb",
        }

        self._log(f"Scanning {len(common_ports)} common ports on {target}...")

        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1.5)
                result = sock.connect_ex((target, port))
                if result == 0:
                    open_ports.append(port)
                    svc_name = service_names.get(port, f"unknown-{port}")

                    # Try to grab banner
                    banner = ""
                    try:
                        sock.settimeout(2)
                        sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
                        banner = sock.recv(256).decode("utf-8", errors="replace").strip()
                    except Exception:
                        pass

                    services.append({
                        "port": port,
                        "name": svc_name,
                        "version": banner[:80] if banner else "",
                    })
                sock.close()
            except Exception:
                pass

        return {
            "target": target,
            "open_ports": open_ports,
            "services": services,
            "scan_type": "python_connect_scan",
        }

    # ================================================================
    # Phase 3: KnowledgeGraph Ingestion
    # ================================================================

    async def phase_ingest(self, scan_result: Dict[str, Any]):
        """Ingest scan results into KnowledgeGraph."""
        self._print_banner("PHASE 3: KNOWLEDGE GRAPH INGESTION")

        self.kg.add_host(self.target)
        for svc in scan_result.get("services", []):
            self.kg.add_port(self.target, svc["port"], "open")
            self.kg.add_service(self.target, svc["port"],
                                svc["name"], svc.get("version", ""))

        stats = self.kg.get_stats()
        self._log(f"Graph: {stats['total_nodes']} nodes, {stats['total_edges']} edges")

    # ================================================================
    # Phase 4: Brain Analysis
    # ================================================================

    async def phase_analyze(self, scan_result: Dict[str, Any]) -> str:
        """Brain analyzes scan results and identifies attack vectors."""
        self._print_banner("PHASE 4: BRAIN ANALYSIS")
        self.mem.set_status("ANALYSIS")

        services_desc = "\n".join(
            f"  - {s['port']}/tcp: {s['name']} {s.get('version', '')}"
            for s in scan_result.get("services", [])
        )

        if not services_desc:
            self._log("No open ports found - skipping analysis")
            return "No attack vectors - all ports closed"

        prompt = f"""You are a cybersecurity consultant performing an authorized security assessment.
Target: {self.target} (client-authorized, private LAN).

Open ports and services found:
{services_desc}

For EACH service found:
1. List known CVEs (use format CVE-YYYY-NNNNN with regular hyphens)
2. Rate severity (critical/high/medium/low)
3. Suggest one-line exploit command or technique
4. Note if default credentials are common

Use this format:
PORT - SERVICE - CVE-XXXX-XXXX (severity) - exploit approach"""

        try:
            await asyncio.sleep(10)  # Rate limit buffer
            analysis = await self.client.call_brain(prompt, temperature=0.3)
            self.mem.update_task_status("analysis", "COMPLETE", analysis[:300])
            self._log("Brain analysis:")
            print(analysis[:800], flush=True)

            # Extract findings from analysis
            self._extract_findings(analysis, scan_result)

            return analysis
        except Exception as e:
            self._error("Brain analysis", e)
            return "Analysis failed"

    def _extract_findings(self, analysis: str, scan_result: Dict):
        """Extract CVE findings from Brain's analysis text."""
        # Match CVE IDs with both regular hyphens (-) and Unicode dashes
        # Unicode: U+2010 (hyphen), U+2011 (non-breaking hyphen), U+2013 (en dash)
        normalized = analysis.replace('\u2010', '-').replace('\u2011', '-').replace('\u2013', '-')
        cve_pattern = r"CVE-\d{4}-\d{4,7}"
        cves_found = re.findall(cve_pattern, normalized)

        for cve in set(cves_found):
            # Determine severity from context near the CVE mention
            cve_idx = normalized.lower().find(cve.lower())
            context = normalized[max(0, cve_idx-100):cve_idx+100].lower() if cve_idx >= 0 else ""
            if "critical" in context:
                severity = "critical"
            elif "high" in context:
                severity = "high"
            elif "medium" in context:
                severity = "medium"
            else:
                severity = "high"  # Default to high for CVEs

            service_context = ""
            for svc in scan_result.get("services", []):
                svc_name = svc["name"].lower()
                if svc_name in normalized.lower():
                    service_context = f"{svc['name']} on port {svc['port']}"
                    # Add to knowledge graph
                    svc_id = f"{self.target}:{svc['port']}:{svc['name']}"
                    self.kg.add_vulnerability(svc_id, cve, severity)
                    break

            self.mem.add_finding(
                f"{cve} - {service_context or 'unknown service'}",
                severity,
            )
            self._log(f"  Finding: {cve} [{severity}] {service_context}")

    # ================================================================
    # Phase 5: Hands Exploit Generation
    # ================================================================

    async def phase_exploit(self, analysis: str, scan_result: Dict) -> str:
        """Hands generates exploit code based on Brain's analysis."""
        self._print_banner("PHASE 5: HANDS EXPLOIT GENERATION")
        self.mem.set_status("EXPLOITATION")

        if not scan_result.get("services"):
            self._log("No services to exploit")
            return ""

        # Pick most interesting service for exploit code
        services_desc = ", ".join(
            f"{s['port']}/{s['name']}" for s in scan_result["services"][:3]
        )

        prompt = f"""You are a cybersecurity consultant writing a security testing script.
Client has authorized testing of {self.target} (private LAN).
Services found: {services_desc}

Write a Python security audit script that:
1. Import only stdlib (socket, http.client, urllib)
2. Test for common misconfigurations on each open port
3. Check for default credentials
4. Print findings clearly

Keep it under 50 lines. Working code only."""

        try:
            await asyncio.sleep(10)
            code = await self.client.call_hands(prompt, temperature=0.2)
            self.mem.update_task_status("exploit_gen", "COMPLETE", "Exploit code generated")
            self._log("Hands exploit code:")
            print(code[:600], flush=True)
            return code
        except Exception as e:
            self._error("Hands exploit", e)
            return ""

    # ================================================================
    # Phase 6: Report Generation
    # ================================================================

    async def phase_report(self, scan_result: Dict, analysis: str):
        """Generate CausalChain report."""
        self._print_banner("PHASE 6: REPORT GENERATION")
        self.mem.set_status("REPORTING")

        findings = []
        for i, f in enumerate(self.mem.get_current_state()["key_findings"], 1):
            finding = {
                "id": i,
                "title": f["finding"],
                "cve": re.search(r"CVE-\d{4}-\d+", f["finding"]).group(0) if re.search(r"CVE-\d{4}-\d+", f["finding"]) else "N/A",
                "cvss": 9.8 if f["severity"] == "critical" else 7.5 if f["severity"] == "high" else 5.0,
                "service": f["finding"].split(" - ")[-1] if " - " in f["finding"] else "unknown",
                "impact": "Potential Remote Code Execution" if f["severity"] in ["critical", "high"] else "Information Disclosure",
                "root_cause": f"Vulnerability identified by Brain analysis",
                "steps": [
                    f"Port scan discovered service on {self.target}",
                    f"Brain analysis identified {f['finding']}",
                    "Exploit code generated by Hands model",
                ],
                "target": {"os": "Unknown", "software": f["finding"]},
            }
            findings.append(finding)

        if not findings:
            self._log("No findings to report - generating summary only")
            findings = [{
                "id": 1,
                "title": f"No critical vulnerabilities found on {self.target}",
                "cve": "N/A",
                "cvss": 0,
                "service": "multiple",
                "impact": "None",
                "root_cause": "Services appear properly configured",
                "steps": [f"Scanned {self.target}", "No exploitable vulnerabilities identified"],
                "target": {"os": "Unknown", "software": "N/A"},
            }]

        report_data = {
            "completed_tasks": findings,
            "executive_summary": f"Penetration test of {self.target}. "
                                  f"Found {len(self.mem.get_current_state()['key_findings'])} findings.",
            "attack_path": {
                "target": self.target,
                "ports": [s["port"] for s in scan_result.get("services", [])],
            },
        }

        try:
            full_report = self.reporter.generate_full_report(report_data, f"Pentest - {self.target}")
            txt_path = self.reporter.export_text(full_report)
            json_path = self.reporter.export_json(full_report)

            self.mem.update_task_status("report", "COMPLETE", f"Report: {txt_path}")
            self._log(f"Text report: {txt_path}")
            self._log(f"JSON report: {json_path}")
        except Exception as e:
            self._error("Report generation", e)

    # ================================================================
    # Main Runner
    # ================================================================

    async def run(self):
        """Execute the full autonomous pentest."""
        try:
            await self.setup()

            # Phase 1: Plan
            plan = await self.phase_planning()
            await asyncio.sleep(5)

            # Phase 2: Recon
            scan_result = await self.phase_recon()

            # Phase 3: Ingest
            await self.phase_ingest(scan_result)

            # Phase 4: Analyze
            analysis = await self.phase_analyze(scan_result)

            # Phase 5: Exploit
            exploit_code = await self.phase_exploit(analysis, scan_result)

            # Phase 6: Report
            await self.phase_report(scan_result, analysis)

            # Final
            self._print_banner("PENTEST COMPLETE")
            self.mem.set_status("COMPLETE")

            elapsed = time.time() - self.start_time
            state = self.mem.get_current_state()
            graph = self.kg.get_stats()

            self._log(f"Time: {elapsed:.1f}s")
            self._log(f"Completed tasks: {len(state['completed_tasks'])}")
            self._log(f"Findings: {len(state['key_findings'])}")
            self._log(f"Knowledge Graph: {graph['total_nodes']} nodes")
            self._log(f"Work dir: {self.work_dir}")

            if self.errors:
                print(f"\nErrors encountered: {len(self.errors)}", flush=True)
                for err in self.errors:
                    print(f"  [{err['phase']}] {err['error']}", flush=True)

            # Cleanup
            self.locks.cleanup()

        except Exception as e:
            logger.error(f"Pentest failed: {e}")
            import traceback
            traceback.print_exc()

    # ================================================================
    # Helpers
    # ================================================================

    def _print_banner(self, title: str):
        print(f"\n{'=' * 60}", flush=True)
        print(f"  {title}", flush=True)
        print(f"{'=' * 60}\n", flush=True)

    def _log(self, msg: str):
        print(f"  [*] {msg}", flush=True)

    def _error(self, phase: str, exc: Exception):
        err_msg = str(exc)[:200]
        self.errors.append({"phase": phase, "error": err_msg})
        print(f"  [!] {phase} error: {err_msg}", flush=True)
        logger.error(f"{phase}: {exc}")


# ================================================================
# Entry Point
# ================================================================

async def main():
    if len(sys.argv) < 2:
        print("Usage: python -m redclaw.pentest <TARGET_IP>")
        print("   or: python redclaw_pentest.py <TARGET_IP>")
        sys.exit(1)

    target = sys.argv[1]
    api_key = os.getenv("OPENROUTER_API_KEY",
                         "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")

    pentest = RedClawPentest(target=target, api_key=api_key)
    await pentest.run()


if __name__ == "__main__":
    logging.basicConfig(level=logging.WARNING, format="%(message)s")
    asyncio.run(main())
